<!doctype html>
<html>
<head>
    <link href="qunit-git.css" type="text/css" rel="stylesheet" />
    <style type="text/css">

    </style>
</head>
<body>
    <h2>All Paths</h2>
    <div id="allPathsCt"></div>
    <div id="allPaths"></div>
    <h2>Shortest Path(s)</h2>
    <div id="shortPathsCt"></div>
    <div id="shortPaths"></div>


    <div style="width:500px;">
    <h1 id="qunit-header">QUnit tests</h1>  
    <h2 id="qunit-banner"></h2>  
    <h2 id="qunit-userAgent"></h2>  
    <ol id="qunit-tests">  
    </div>

    <script type="text/javascript" src="jquery-1.7.1.js"></script>
    <script type="text/javascript" src="qunit-git.js"></script>
    <script type="text/javascript">
        (function () {
            "use strict";
            /*
              to do:
             * create graph randomizer
             * find shortest unique paths
             * report output
             * graph visualizer (raphael?)
             * modularize (require.js?)
             * allPaths a method on Node?
             * Node needs undirected edges!
             * access nodes by both name and index!
             * path API is cumbersome!
             * fix vim auto-indenting!!
             * will it still work if I make add() mutable??

            */

            function createNode(name, children) {
                var _name = name || '',
                    _children = children || [],
                    that = {
                        name: _name,
                        children: _children,
                        hasChild: function(c) {
                            return that.children.indexOf(c) !== -1;
                        },
                        add: function(c) {
                            // edges need to be bi-directional, so add to
                            // children too
                            if (!that.hasChild(c)) {
                                that.children.push(c);
                            }
                            if (!c.hasChild(that)) {
                                c.children.push(that);
                            }
                        },
                        toString: function() { return _name; }
                    };

                $.each(that.children, function(i,c) {
                    that.add(c);
                });

                return that;
            };

            /**
            createPath - immutable path data structure.
            `add` does not modify the current instance, it 
            returns a new instance with the new node added
            */
            function createPath(arr) {
                var _arr = arr || [];

                return {
                    contains: function (node) {
                        return _arr.indexOf(node) !== -1;
                    },
                    add: function (node) {
                        // copy path array, add new node, return new path
                        var a = _arr.slice(0);
                        a.push(node);
                        return createPath(a);
                    },
                    toArr: function () {
                        return _arr.slice(0);
                    },
                    toString: function() {
                        var i,
                            s = '';
                        if (_arr.length > 0) {
                            s = _arr[0].name;
                        }
                        for(i=1; i < _arr.length; i++) {
                            s = s + " -> " + _arr[i].name;
                        }

                        return s;
                    }
                };
            }

            function allPaths(node, dest) {

                var paths = [];
                _allPaths(node, dest, createPath());
                return paths;

                function _allPaths(node, dest, path) {
                    var i, newPath;

                    // abort traversal if we're in a loop
                    if (path.contains(node)) {
                        return;
                    }

                    newPath = path.add(node);
                    if (node === dest) {
                        // abort traversal and return the 
                        paths.push(newPath);
                        return;
                    }

                    for (i = 0; i < node.children.length; i++) {
                        _allPaths(node.children[i], dest, newPath);
                    }
                }
            }

            /**
              create random edges among a list of edges,
              creating an edge between any two nodes 
              with probability p
            */
            function randomizeGraph(p, nodeArr) {

                // start fresh
                $.each(nodeArr, function(i,n) {
                    n.children = [];
                });

                // add edges randomly
                $.each(nodeArr, function(i,n) {
                    var j;
                    for(j=i+1; j < nodeArr.length; j++) {
                        if (Math.random() < p) {
                            n.add(nodeArr[j]);
                        }
                    }
                });
            }

            var na = [
                    createNode("s"),
                    createNode("d"),
                    createNode("a"),
                    createNode("b"),
                    createNode("c"),
                    createNode("d"),
                    createNode("e"),
                    createNode("f")
                ];

            randomizeGraph(0.3, na);

            var paths = allPaths(na[0], na[1]);

            $('#allPathsCt').text(paths.length);
            for(var i=0; i < paths.length; i++) {
              $('#allPaths').append($("<p>" + paths[i].toString() + "</p>"))

            }


            /*
            QUnit tests
            http://docs.jquery.com/QUnit
            */
            test("createNode should assign node name", function() {
                var n = createNode("foo");

                equal(n.name, "foo");
            });
            test("randomizeGraph creates no edges for p=0", function() {

                var na = [
                        createNode("s"),
                        createNode("d"),
                        createNode("1"),
                        createNode("2"),
                        createNode("3"),
                        createNode("4"),
                        createNode("5"),
                        createNode("6"),
                    ];
                    
                    randomizeGraph(0, na);

                    $.each(na, function(i,n) {
                        equal(0, n.children.length);
                    });

            });
            test("randomizeGraph creates fully connected graph for p=1", function() {
                var na = [
                        createNode("s"),
                        createNode("d"),
                        createNode("1"),
                        createNode("2"),
                        createNode("3"),
                        createNode("4"),
                        createNode("5"),
                        createNode("6"),
                    ];
                    
                    randomizeGraph(1, na);

                    $.each(na, function(i,n) {
                        equal(na.length-1, n.children.length);
                    });

            });
            test("allPaths should return single node if src and dest are equal", function () {
                var n = createNode("s"),
                    paths;

                paths = allPaths(n, n);

                equal(paths.length, 1);
                equal(paths[0].toArr().length, 1);
                equal(paths[0].toArr()[0].name, "s");
            });
            test("allPaths should return empty array if no path from src to dest", function() {

                var d = createNode("d"),
                    n = createNode("s", [
                          createNode("1"),
                          createNode("2"),
                          createNode("3"),
                        ]),
                    paths;

                paths = allPaths(n, d);

                equal(paths.length, 0);
            });
            test("allPaths handles loops correctly", function() {

                var d = createNode("d"),
                    n = createNode("s", [
                          createNode("1", [
                            createNode("3", [d])
                          ]),
                          createNode("2", [
                            createNode("4", [d])
                          ]),
                        ]),
                    paths;

                // add cycles: 3-2
                n.children[0].children[0].add(
                  n.children[1]
                );

                paths = allPaths(n, d);

                // correct # paths?
                equal(paths.length, 4);

                // each path starts with 'n' and ends with 'd'?
                $.each(paths, function(i,p) {
                    equal('s', p.toArr()[0].name);
                    equal('d', p.toArr()[ p.toArr().length-1 ].name);
                });
            });
        })();
    </script>
</body>
</html>
