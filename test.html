<!doctype html>
<html>
<head>
    <link href="qunit-git.css" type="text/css" rel="stylesheet" />
    <style type="text/css">
        #allPaths p, #shortPaths p {
            margin-top: 0px;
            margin-bottom: 0px;
        }

        /*
        #allPaths, #shortPaths {
            height: 300px;
            width: 300px;
            overflow: auto;
        }
        */

    </style>
</head>
<body>
    <h2>All Paths</h2>
    <div id="allPathsCt"></div>
    <div id="allPaths"></div>
    <h2>Shortest Path(s)</h2>
    <div id="shortPathsCt"></div>
    <div id="shortPaths"></div>

    <div id="graphContainer">


    </div>


    <div style="width:500px;">
    <h1 id="qunit-header">QUnit tests</h1>  
    <h2 id="qunit-banner"></h2>  
    <h2 id="qunit-userAgent"></h2>  
    <ol id="qunit-tests">  
    </div>

    <script type="text/javascript" src="jquery-1.7.1.js"></script>
    <script type="text/javascript" src="qunit-git.js"></script>
    <script type="text/javascript" src="raphael.js"></script>
    <script type="text/javascript">
        (function () {
            "use strict";


            /*
               MUST do:
               2) implement, display shortest-path 

               Nice to do:
               * allow user to change node list on the fly
               * allow user to select source, destination nodes
               * highlight shortest paths
               * re-arrange, pretify layout
               * modularize (require.js?)
               * allPaths a method on Node?

            */

            function createNode(name, children) {
                var _name = name || '',
                    _children = children || [],
                    that = {
                        name: _name,
                        children: _children,
                        hasChild: function(c) {
                            return that.children.indexOf(c) !== -1;
                        },
                        add: function(c) {
                            // edges need to be bi-directional, so add to
                            // children too
                            if (!that.hasChild(c)) {
                                that.children.push(c);
                            }
                            if (!c.hasChild(that)) {
                                c.children.push(that);
                            }
                        },
                        toString: function() { return _name; }
                    };

                $.each(that.children, function(i,c) {
                    that.add(c);
                });

                return that;
            };

            /**
            createPath - immutable path data structure.
            `add` does not modify the current instance, it 
            returns a new instance with the new node added
            */
            function createPath(arr) {
                var _arr = arr || [];

                return {
                    contains: function (node) {
                        return _arr.indexOf(node) !== -1;
                    },
                    add: function (node) {
                        // copy path array, add new node, return new path
                        var a = _arr.slice(0);
                        a.push(node);
                        return createPath(a);
                    },
                    toArr: function () {
                        return _arr.slice(0);
                    },
                    getLength: function() {
                        return _arr.length;
                    },
                    toString: function() {
                        var i,
                            s = '';
                        if (_arr.length > 0) {
                            s = _arr[0].name;
                        }
                        for(i=1; i < _arr.length; i++) {
                            s = s + "&rarr;" + _arr[i].name;
                        }

                        return s;
                    }
                };
            }

            function allPaths(node, dest) {

                var paths = [];
                _allPaths(node, dest, createPath());
                return paths;

                function _allPaths(node, dest, path) {
                    var i, newPath;

                    // abort traversal if we're in a loop
                    if (path.contains(node)) {
                        return;
                    }

                    newPath = path.add(node);
                    if (node === dest) {
                        // abort traversal and return the 
                        paths.push(newPath);
                        return;
                    }

                    for (i = 0; i < node.children.length; i++) {
                        _allPaths(node.children[i], dest, newPath);
                    }
                }
            }

            function shortestPaths(node, dest) {
                var paths = [],
                    visitedEdges = {},
                    min = Infinity,
                    ap = allPaths(node, dest);

                $.each(ap, function(i,path) {

                    if (path.getLength() < min) {
                        // we found a new minimum path length,
                        // so start over
                        paths = [path];
                        visitedEdges = {};
                        markEdges(path);
                        min = path.getLength();
                    }
                    else if (path.getLength() === min) {
                        // we found a new path with the minimum
                        // length. Add it if it does not have
                        // any edges in common with existing
                        //shortest paths
                        if (!hasVisitedEdges(path)) {
                            paths.push(path);
                            markEdges(path);
                        }
                    }
                });

                return paths;

                /* private helper functions */
                function markEdges(path) {
                    var i,
                        nodes = path.toArr();
                    for(i=1; i < nodes.length; i++) {
                        visitedEdges[ nodes[i-1] ] = nodes[i];
                        visitedEdges[ nodes[i] ] = nodes[i-1];
                    }

                }
                function hasVisitedEdges(path) {
                    var i,
                        nodes = path.toArr();

                    for(i=1; i < nodes.length; i++) {
                        if (visitedEdges[ nodes[i] ] === nodes[i-1]) {
                            return true;
                        }
                    }

                    return false;
                }
            }

            /**
              create random edges among a list of edges,
              creating an edge between any two nodes 
              with probability p
            */
            function randomizeGraph(p, nodeArr) {

                // start fresh
                $.each(nodeArr, function(i,n) {
                    n.children = [];
                });

                // add edges randomly
                $.each(nodeArr, function(i,n) {
                    var j;
                    for(j=i+1; j < nodeArr.length; j++) {
                        if (Math.random() < p) {
                            n.add(nodeArr[j]);
                        }
                    }
                });
            }

            function createGraphDrawer(nodes) {

                // need to be able to map easily between nodes and circles
                // also between edges and lines
                var _width=640,
                    _height=480,
                    _r = Raphael("graphContainer", _width, _height),
                    _circles = [],
                    _nodeToCircle = {},
                    _circleToNode = {},
                    that;

                that = {
                    nodes: nodes || [],
                    draw: function() {
                        var angle = 0;

                        // draw nodes
                        $.each(that.nodes, function(i,n) {
                            var c = Raphael.getColor(),
                                t = "r" + angle + " " + _width/2 + " " + _height/2,
                                circle;

                            // draw circle for node
                            circle = _r.circle(320, 450, 10).attr({transform: t, "fill-opacity": .4});
                            _r.text(320,450,n.name).attr({stroke: c, fill: c, transform: t, "fill-opacity": .4});

                            // save circle reference, and map so that lookups
                            // are easy
                            _circles.push(circle);
                            _nodeToCircle[n] = circle;
                            _circleToNode[circle] = n;

                            // increment length the appropriate amount
                            angle = angle + (360 / nodes.length);
                        });

                        // draw edges
                        // to do: do not draw them twice!
                        $.each(nodes, function(i,n) {
                            $.each(n.children, function(j,c) {
                                var c1 = _nodeToCircle[n],
                                    bb1 = c1.getBBox(),
                                    x1 = bb1.x + bb1.width/2,
                                    y1 = bb1.y + bb1.height/2,
                                    c2 = _nodeToCircle[c],
                                    bb2 = c2.getBBox(),
                                    x2 = bb2.x + bb2.width/2,
                                    y2 = bb2.y + bb2.height/2;

                                _r.path("M" + x1 + "," + y1 + 
                                        "L" + x2 + "," + y2);
                            });
                        });
                    }

                }

                return that;
            };

            var na = [
                    createNode("source"),
                    createNode("destination"),
                    createNode("a"),
                    createNode("b"),
                    createNode("c"),
                    createNode("d"),
                    createNode("e"),
                    createNode("f"),
                    createNode("g"),
                    createNode("h"),
                    createNode("i"),
                    createNode("j"),
                    createNode("k"),
                    createNode("l")
                ];

            randomizeGraph(0.15, na);
            var d = createGraphDrawer(na);
            d.draw();

            var paths = allPaths(na[0], na[1]);

            $('#allPathsCt').text(paths.length);
            for(var i=0; i < paths.length; i++) {
                $('#allPaths').append($("<p>" + paths[i].toString() + "</p>"))
            }

            var shortPaths = shortestPaths(na[0], na[1]);
            $('#shortPathsCt').text(shortPaths.length);
            for(var i=0; i < shortPaths.length; i++) {
                $('#shortPaths').append($("<p>" + shortPaths[i].toString() + "</p>"))
            }


            /*
            QUnit tests
            http://docs.jquery.com/QUnit
            */
            test("createNode should assign node name", function() {
                var n = createNode("foo");

                equal(n.name, "foo");
            });
            test("randomizeGraph creates no edges for p=0", function() {

                var na = [
                        createNode("s"),
                        createNode("d"),
                        createNode("1"),
                        createNode("2"),
                        createNode("3"),
                        createNode("4"),
                        createNode("5"),
                        createNode("6"),
                    ];
                    
                    randomizeGraph(0, na);

                    $.each(na, function(i,n) {
                        equal(0, n.children.length);
                    });

            });
            test("randomizeGraph creates fully connected graph for p=1", function() {
                var na = [
                        createNode("s"),
                        createNode("d"),
                        createNode("1"),
                        createNode("2"),
                        createNode("3"),
                        createNode("4"),
                        createNode("5"),
                        createNode("6"),
                    ];
                    
                    randomizeGraph(1, na);

                    $.each(na, function(i,n) {
                        equal(na.length-1, n.children.length);
                    });

            });
            test("allPaths should return single node if src and dest are equal", function () {
                var n = createNode("s"),
                    paths;

                paths = allPaths(n, n);

                equal(paths.length, 1);
                equal(paths[0].toArr().length, 1);
                equal(paths[0].toArr()[0].name, "s");
            });
            test("allPaths should return empty array if no path from src to dest", function() {

                var d = createNode("d"),
                    n = createNode("s", [
                          createNode("1"),
                          createNode("2"),
                          createNode("3"),
                        ]),
                    paths;

                paths = allPaths(n, d);

                equal(paths.length, 0);
            });
            test("allPaths handles loops correctly", function() {

                var d = createNode("d"),
                    n = createNode("s", [
                          createNode("1", [
                            createNode("3", [d])
                          ]),
                          createNode("2", [
                            createNode("4", [d])
                          ]),
                        ]),
                    paths;

                // add cycles: 3-2
                n.children[0].children[0].add(
                  n.children[1]
                );

                paths = allPaths(n, d);

                // correct # paths?
                equal(paths.length, 4);

                // each path starts with 'n' and ends with 'd'?
                $.each(paths, function(i,p) {
                    equal('s', p.toArr()[0].name);
                    equal('d', p.toArr()[ p.toArr().length-1 ].name);
                });
            });
            test("allPaths is symmetric", function() {
                var d = createNode("d"),
                    n = createNode("s", [
                          createNode("1", [
                            createNode("3", [d])
                          ]),
                          createNode("2", [
                            createNode("4", [d])
                          ]),
                        ]);

                // add cycles: 3-2
                n.children[0].children[0].add(
                  n.children[1]
                );

                var paths1 = allPaths(n, d);
                var paths2 = allPaths(d, n);

                equal(paths1.length, paths2.length);

            });
        })();
    </script>
</body>
</html>
