<!doctype html>
<html>
<head>
    <link href="qunit-git.css" type="text/css" rel="stylesheet" />
    <style type="text/css">
        #allPaths p, #shortPaths p {
            margin-top: 0px;
            margin-bottom: 0px;
        }

        #allPaths, #shortPaths {
            height: 300px;
            width: 300px;
            overflow: auto;
        }

    </style>
</head>
<body>
    <h2>All Paths</h2>
    <div id="allPathsCt"></div>
    <div id="allPaths"></div>
    <h2>Shortest Path(s)</h2>
    <div id="shortPathsCt"></div>
    <div id="shortPaths"></div>

    <div id="graphContainer">


    </div>


    <div style="width:500px;">
    <h1 id="qunit-header">QUnit tests</h1>  
    <h2 id="qunit-banner"></h2>  
    <h2 id="qunit-userAgent"></h2>  
    <ol id="qunit-tests">  
    </div>

    <script type="text/javascript" src="jquery-1.7.1.js"></script>
    <script type="text/javascript" src="qunit-git.js"></script>
    <script type="text/javascript" src="raphael.js"></script>
    <script type="text/javascript">
        (function () {
            "use strict";


            /*
              to do:
             * create graph randomizer
             * find shortest unique paths
             * report output
             * graph visualizer (raphael?)
             * modularize (require.js?)
             * allPaths a method on Node?
             * Node needs undirected edges!
             * access nodes by both name and index!
             * path API is cumbersome!
             * fix vim auto-indenting!!
             * will it still work if I make add() mutable??

            */

            function createNode(name, children) {
                var _name = name || '',
                    _children = children || [],
                    that = {
                        name: _name,
                        children: _children,
                        hasChild: function(c) {
                            return that.children.indexOf(c) !== -1;
                        },
                        add: function(c) {
                            // edges need to be bi-directional, so add to
                            // children too
                            if (!that.hasChild(c)) {
                                that.children.push(c);
                            }
                            if (!c.hasChild(that)) {
                                c.children.push(that);
                            }
                        },
                        toString: function() { return _name; }
                    };

                $.each(that.children, function(i,c) {
                    that.add(c);
                });

                return that;
            };

            /**
            createPath - immutable path data structure.
            `add` does not modify the current instance, it 
            returns a new instance with the new node added
            */
            function createPath(arr) {
                var _arr = arr || [];

                return {
                    contains: function (node) {
                        return _arr.indexOf(node) !== -1;
                    },
                    add: function (node) {
                        // copy path array, add new node, return new path
                        var a = _arr.slice(0);
                        a.push(node);
                        return createPath(a);
                    },
                    toArr: function () {
                        return _arr.slice(0);
                    },
                    toString: function() {
                        var i,
                            s = '';
                        if (_arr.length > 0) {
                            s = _arr[0].name;
                        }
                        for(i=1; i < _arr.length; i++) {
                            s = s + "&rarr;" + _arr[i].name;
                        }

                        return s;
                    }
                };
            }

            function allPaths(node, dest) {

                var paths = [];
                _allPaths(node, dest, createPath());
                return paths;

                function _allPaths(node, dest, path) {
                    var i, newPath;

                    // abort traversal if we're in a loop
                    if (path.contains(node)) {
                        return;
                    }

                    newPath = path.add(node);
                    if (node === dest) {
                        // abort traversal and return the 
                        paths.push(newPath);
                        return;
                    }

                    for (i = 0; i < node.children.length; i++) {
                        _allPaths(node.children[i], dest, newPath);
                    }
                }
            }

            /**
              create random edges among a list of edges,
              creating an edge between any two nodes 
              with probability p
            */
            function randomizeGraph(p, nodeArr) {

                // start fresh
                $.each(nodeArr, function(i,n) {
                    n.children = [];
                });

                // add edges randomly
                $.each(nodeArr, function(i,n) {
                    var j;
                    for(j=i+1; j < nodeArr.length; j++) {
                        if (Math.random() < p) {
                            n.add(nodeArr[j]);
                        }
                    }
                });
            }

            function createGraphDrawer(nodes) {

                // need to be able to map easily between nodes and circles
                // also between edges and lines
                var _width=640,
                    _height=480,
                    _r = Raphael("graphContainer", _width, _height),
                    _circles = [],
                    _nodeToCircle = {},
                    _circleToNode = {},
                    that;

                that = {
                    nodes: nodes || [],
                    draw: function() {
                        var angle = 0;

                        // draw nodes
                        $.each(that.nodes, function(i,n) {
                            var c = Raphael.getColor(),
                                t = "r" + angle + " " + _width/2 + " " + _height/2,
                                circle;

                            // draw circle for node
                            circle = _r.circle(320, 450, 10).attr({stroke: c, fill: c, transform: t, "fill-opacity": .4});

                            // save circle reference, and map so that lookups
                            // are easy
                            _circles.push(circle);
                            _nodeToCircle[n] = circle;
                            _circleToNode[circle] = n;

                            // increment length the appropriate amount
                            angle = angle + (360 / nodes.length);
                        });

                        // draw edges
                        $.each(nodes, function(i,n) {
                            $.each(n.children, function(j,c) {
                                var c1 = _nodeToCircle[n],
                                    bb1 = c1.getBBox(),
                                    x1 = bb1.x + bb1.width/2,
                                    y1 = bb1.y + bb1.height/2,
                                    c2 = _nodeToCircle[c],
                                    bb2 = c2.getBBox(),
                                    x2 = bb2.x + bb2.width/2,
                                    y2 = bb2.y + bb2.height/2;

                                _r.path("M" + x1 + "," + y1 + 
                                        "L" + x2 + "," + y2);
                            });
                        });

                    }

                }

                return that;
            };
            /*
            function drawGraph(nodes) {

              var width=640,
                  height=480,
                  r = Raphael("graphContainer", width, height),
                  angle = 0,
                  drawNodes = [],
                  i;

              $.each(nodes, function(i,n) {
                  var c = Raphael.getColor(),
                      t = "r" + angle + " " + width/2 + " " + height/2;

                  drawNodes.push({
                      circle: r.circle(320, 450, 10).attr({stroke: c, fill: c, transform: t, "fill-opacity": .4}),
                      node: n
                  });

                  // increment length the appropriate amount
                  angle = angle + (360 / nodes.length);
              });


                while (angle < 360) {
                    var color = Raphael.getColor();
                    (function (t, c) {
                        r.circle(320, 450, 20).attr({stroke: c, fill: c, transform: t, "fill-opacity": .4}).click(function () {
                            s.animate({transform: t, stroke: c}, 2000, "bounce");
                        }).mouseover(function () {
                            this.animate({"fill-opacity": .75}, 500);
                        }).mouseout(function () {
                            this.animate({"fill-opacity": .4}, 500);
                        });
                    })("r" + angle + " 320 240", color);
                    angle += 30;
                }
                Raphael.getColor.reset();
                var s = r.set();
                s.push(r.path("M320,240l-0,190").attr({fill: "none", "stroke-width": 2}));
                s.push(r.circle(320, 450, 20).attr({fill: "none", "stroke-width": 2}));
                s.push(r.circle(320, 240, 5).attr({fill: "none", "stroke-width": 10}));
                s.attr({stroke: Raphael.getColor()});
            }
                */

            var na = [
                    createNode("s"),
                    createNode("d"),
                    createNode("a"),
                    createNode("b"),
                    createNode("c"),
                    createNode("d"),
                    createNode("e"),
                    createNode("e"),
                    createNode("e"),
                    createNode("e"),
                    createNode("e"),
                    createNode("e"),
                    createNode("e"),
                    createNode("f")
                ];

            randomizeGraph(0.3, na);
            var d = createGraphDrawer(na);
            d.draw();

            var paths = allPaths(na[0], na[1]);

            $('#allPathsCt').text(paths.length);
            for(var i=0; i < paths.length; i++) {
              $('#allPaths').append($("<p>" + paths[i].toString() + "</p>"))

            }


            /*
            QUnit tests
            http://docs.jquery.com/QUnit
            */
            test("createNode should assign node name", function() {
                var n = createNode("foo");

                equal(n.name, "foo");
            });
            test("randomizeGraph creates no edges for p=0", function() {

                var na = [
                        createNode("s"),
                        createNode("d"),
                        createNode("1"),
                        createNode("2"),
                        createNode("3"),
                        createNode("4"),
                        createNode("5"),
                        createNode("6"),
                    ];
                    
                    randomizeGraph(0, na);

                    $.each(na, function(i,n) {
                        equal(0, n.children.length);
                    });

            });
            test("randomizeGraph creates fully connected graph for p=1", function() {
                var na = [
                        createNode("s"),
                        createNode("d"),
                        createNode("1"),
                        createNode("2"),
                        createNode("3"),
                        createNode("4"),
                        createNode("5"),
                        createNode("6"),
                    ];
                    
                    randomizeGraph(1, na);

                    $.each(na, function(i,n) {
                        equal(na.length-1, n.children.length);
                    });

            });
            test("allPaths should return single node if src and dest are equal", function () {
                var n = createNode("s"),
                    paths;

                paths = allPaths(n, n);

                equal(paths.length, 1);
                equal(paths[0].toArr().length, 1);
                equal(paths[0].toArr()[0].name, "s");
            });
            test("allPaths should return empty array if no path from src to dest", function() {

                var d = createNode("d"),
                    n = createNode("s", [
                          createNode("1"),
                          createNode("2"),
                          createNode("3"),
                        ]),
                    paths;

                paths = allPaths(n, d);

                equal(paths.length, 0);
            });
            test("allPaths handles loops correctly", function() {

                var d = createNode("d"),
                    n = createNode("s", [
                          createNode("1", [
                            createNode("3", [d])
                          ]),
                          createNode("2", [
                            createNode("4", [d])
                          ]),
                        ]),
                    paths;

                // add cycles: 3-2
                n.children[0].children[0].add(
                  n.children[1]
                );

                paths = allPaths(n, d);

                // correct # paths?
                equal(paths.length, 4);

                // each path starts with 'n' and ends with 'd'?
                $.each(paths, function(i,p) {
                    equal('s', p.toArr()[0].name);
                    equal('d', p.toArr()[ p.toArr().length-1 ].name);
                });
            });
        })();
    </script>
</body>
</html>
